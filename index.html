<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;

    background-color: #fff;
    --elevated: #fff;
    --link: #0066cc;
    --text: #161616;
    --outline: #007aff;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      --elevated: #121212;
      --link: #58a6ff;
      --text: #fff;
    }
  }

  body {
    color: var(--text);
  }

  a {
    color: var(--link);
    text-decoration: underline;
    text-underline-offset: 4px;
    text-decoration-thickness: 1px;
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100dvh;
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  .md-h1,
  .md-h2,
  .md-h3,
  .md-h4,
  .md-h5,
  .md-h6 {
    font-weight: 700;
  }

  .md-h1 {
    font-size: 2em;
  }

  .md-h2 {
    font-size: 1.5em;
  }

  .md-h3 {
    font-size: 1.25em;
  }

  .md-h4 {
    font-size: 1.1em;
  }

  .md-h5 {
    font-size: 1em;
  }

  .md-h6 {
    font-size: 0.9em;
  }

  .md-code {
    font-family: monospace;
  }

  .md-codeblock {
    font-family: monospace;
  }

  .md-bold {
    font-weight: bold;
  }

  .md-strike {
    text-decoration: line-through;
  }

  .md-italic {
    font-style: italic;
  }

  .md-url {
    cursor: pointer;
  }

  /* JavaScript syntax highlighting */
  .js-keyword {
    color: #cf222e;
    @media (prefers-color-scheme: dark) {
      color: #ff7b72;
    }
  }

  .js-string {
    color: #0a3069;
    @media (prefers-color-scheme: dark) {
      color: #a5d6ff;
    }
  }

  .js-number {
    color: #0550ae;
    @media (prefers-color-scheme: dark) {
      color: #79c0ff;
    }
  }

  .js-comment {
    color: #6e7781;
    @media (prefers-color-scheme: dark) {
      color: #8b949e;
    }
  }

  .js-function {
    color: #8250df;
    @media (prefers-color-scheme: dark) {
      color: #d2a8ff;
    }
  }

  .js-operator {
    color: #cf222e;
    @media (prefers-color-scheme: dark) {
      color: #ff7b72;
    }
  }

  .js-builtin {
    color: #953800;
    @media (prefers-color-scheme: dark) {
      color: #ffa657;
    }
  }

  .js-regex {
    color: #116329;
    @media (prefers-color-scheme: dark) {
      color: #7ee787;
    }
  }

  /* Interactive Code Editor */
  .code-editor {
    display: block;
    margin: 12px 0;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #e1e4e8;
    background: #f6f8fa;
    @media (prefers-color-scheme: dark) {
      border-color: #30363d;
      background: #161b22;
    }
  }

  .code-editor-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: #f1f3f5;
    border-bottom: 1px solid #e1e4e8;
    @media (prefers-color-scheme: dark) {
      background: #21262d;
      border-color: #30363d;
    }
  }

  .code-editor-lang {
    font-size: 12px;
    font-weight: 600;
    color: #57606a;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    @media (prefers-color-scheme: dark) {
      color: #8b949e;
    }
  }

  .code-editor-actions {
    display: flex;
    gap: 6px;
  }

  .code-editor-btn {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    font-size: 12px;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
    font-family: system-ui;
  }

  .code-editor-btn.copy {
    background: #e1e4e8;
    color: #24292f;
    @media (prefers-color-scheme: dark) {
      background: #30363d;
      color: #c9d1d9;
    }
  }

  .code-editor-btn.copy:hover {
    background: #d0d7de;
    @media (prefers-color-scheme: dark) {
      background: #484f58;
    }
  }

  .code-editor-btn.run {
    background: #238636;
    color: #fff;
  }

  .code-editor-btn.run:hover {
    background: #2ea043;
  }

  .code-editor-btn svg {
    width: 14px;
    height: 14px;
  }

  .code-editor-body {
    position: relative;
  }

  .code-editor-textarea {
    display: block;
    width: 100%;
    min-height: 80px;
    padding: 12px;
    margin: 0;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
    font-size: 14px;
    line-height: 1.5;
    tab-size: 2;
    border: none;
    outline: none;
    resize: none;
    background: transparent;
    color: transparent;
    caret-color: var(--text);
    white-space: pre;
    overflow: auto;
    position: relative;
    z-index: 1;
  }

  .code-editor-highlight {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 12px;
    margin: 0;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
    font-size: 14px;
    line-height: 1.5;
    tab-size: 2;
    white-space: pre;
    pointer-events: none;
    overflow: auto;
    z-index: 0;
  }

  .code-editor-output {
    border-top: 1px solid #e1e4e8;
    background: #1b1f23;
    color: #c9d1d9;
    @media (prefers-color-scheme: dark) {
      border-color: #30363d;
    }
  }

  .code-editor-output-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #8b949e;
    background: #161b22;
  }

  .code-editor-output-clear {
    background: none;
    border: none;
    color: #8b949e;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 4px;
  }

  .code-editor-output-clear:hover {
    background: #30363d;
    color: #c9d1d9;
  }

  .code-editor-output-content {
    padding: 10px 12px;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
    font-size: 13px;
    line-height: 1.5;
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .code-editor-output-content:empty::before {
    content: 'No output yet. Click Run to execute.';
    color: #6e7681;
    font-style: italic;
  }

  .code-editor-output-content .log { color: #c9d1d9; }
  .code-editor-output-content .error { color: #f85149; }
  .code-editor-output-content .warn { color: #d29922; }
  .code-editor-output-content .info { color: #58a6ff; }

  #button {
    -webkit-tap-highlight-color: transparent;
    background-color: #0569fa;
    border-radius: 50%;
    border: none;
    bottom: 15px;
    box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, .12);
    color: #fff;
    cursor: pointer;
    display: grid;
    font-weight: 600;
    width: 46px;
    height: 46px;
    outline: none;
    overflow: hidden;
    padding: 0;
    place-items: center;
    position: fixed;
    right: 15px;
    text-decoration: none;
    touch-action: manipulation;
    transition: background-color .3s ease-out;
    user-select: none;
    z-index: 1;
  }

  @media (hover) {
    #button:hover {
      color: #fff;
      background-color: #3c86f3;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, .12);
    }
  }

  #button:focus-visible {
    outline: 2px solid var(--outline);
    outline-offset: 2px;
  }

  span.ripple {
    position: absolute;
    border-radius: 50%;
    transform: scale(0);
    animation: ripple 600ms linear;
    background-color: rgba(255, 255, 255, 0.7);
  }

  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  #menu {
    visibility: hidden;
    transform: scale(0.9) translateY(20px);
    transition: all 100ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;
    display: flex;
    flex-direction: column;
    width: 220px;
    position: fixed;
    right: 16px;
    bottom: 77px;
    box-shadow: 0 19px 38px rgba(0, 0, 0, 0.10), 0 15px 12px rgba(0, 0, 0, 0.05);
    background: var(--elevated);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    z-index: 2;
  }

  #menu.visible {
    opacity: 1;
    transform: scale(1) translateY(0);
    visibility: visible;
  }

  #menu .item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    text-decoration: none;
    text-align: left;
    padding: 10px 14px;
    overflow: hidden;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
    border: none;
    touch-action: manipulation;
    font: 16px / 1.5 system-ui;
    color: var(--text);
  }

  #menu .item:hover {
    background-color: rgba(0, 0, 0, 0.04);
    @media (prefers-color-scheme: dark) {
      background-color: #353535;
    }
  }

  #menu .item:focus-within {
    outline: 2px solid var(--outline);
  }

  #menu .item:first-child {
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
  }

  #menu .item:last-child {
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  }

  #notification {
    visibility: hidden;
    transform: translateY(-30px);
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;

    display: flex;
    flex-direction: column;

    position: fixed;
    right: 17px;
    top: 17px;

    background: #5ad227;
    color: #fff;
    border-radius: 30px;
    font: 18px / 1 system-ui;
    font-weight: 600;
    z-index: 2;
    padding: 10px 20px;
  }

  #notification.visible {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
  }

  @media print {
    .noprint {
      visibility: hidden !important;
    }
  }
</style>
<article contenteditable="plaintext-only" spellcheck autofocus></article>
<button id="button" class="noprint">
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
       stroke="currentColor"
       stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="1"></circle>
    <circle cx="12" cy="5" r="1"></circle>
    <circle cx="12" cy="19" r="1"></circle>
  </svg>
</button>
<div id="menu" class="noprint" role="menu">
  <a class="item" href="#new" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-plus"></use>
    </svg>
    New document
  </a>
  <a class="item" id="qr" href="/qr" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-qrcode"></use>
    </svg>
    Generate QR code
  </a>
  <a class="item" id="share-link" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-share"></use>
    </svg>
    Share document
  </a>
  <a class="item" id="save-as-html" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as HTML
  </a>
  <a class="item" id="save-as-text" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as TEXT
  </a>
  <a class="item" href="https://github.com/antonmedv/textarea" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-github"></use>
    </svg>
    GitHub
  </a>
</div>
<div id="notification" class="noprint"></div>
<script>
  initUI()

  const article = document.querySelector('article')
  const editor = new Editor(article, parseMarkdown)
  article.addEventListener('input', debounce(500, save))
  article.addEventListener('blur', save)
  article.addEventListener('click', event => {
    if (event.target.tagName === 'A') window.open(event.target.getAttribute('href'), '_blank')
  })
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.code === 'KeyS') {
      e.preventDefault()
      downloadHTML()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try {
      localStorage.setItem('hash', hash)
    } catch (e) {
    }
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    editor.set(content)
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = getArticleContent() + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function getArticleContent() {
    // Walk through article children and extract text, including raw code from code editors
    let content = ''
    const walk = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        content += node.textContent
      } else if (node.classList?.contains('code-editor')) {
        content += node.dataset.raw || ''
      } else if (node.childNodes) {
        node.childNodes.forEach(walk)
      }
    }
    walk(article)
    return content
  }

  function updateTitle() {
    const content = getArticleContent()
    const match = content.match(/^\n*#(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function downloadHTML() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelectorAll('.noprint').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }

  async function downloadTXT() {
    updateTitle()
    const text = getArticleContent()

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.txt',
          types: [{
            description: 'TEXT file',
            accept: {'text/plain': ['.txt']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(text)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([text], {type: 'text/plain'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.txt'
    a.click()
    URL.revokeObjectURL(url)
  }

  const jsKeywords = new Set([
    'async', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue',
    'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'finally',
    'for', 'function', 'if', 'import', 'in', 'instanceof', 'let', 'new', 'of',
    'return', 'static', 'super', 'switch', 'this', 'throw', 'try', 'typeof',
    'var', 'void', 'while', 'with', 'yield', 'true', 'false', 'null', 'undefined'
  ])

  const jsBuiltins = new Set([
    'console', 'window', 'document', 'Array', 'Object', 'String', 'Number',
    'Boolean', 'Function', 'Symbol', 'Map', 'Set', 'WeakMap', 'WeakSet',
    'Promise', 'Proxy', 'Reflect', 'JSON', 'Math', 'Date', 'RegExp', 'Error',
    'TypeError', 'SyntaxError', 'ReferenceError', 'parseInt', 'parseFloat',
    'isNaN', 'isFinite', 'encodeURI', 'decodeURI', 'setTimeout', 'setInterval',
    'clearTimeout', 'clearInterval', 'fetch', 'URL', 'URLSearchParams',
    'TextEncoder', 'TextDecoder', 'Blob', 'File', 'FileReader', 'FormData',
    'XMLHttpRequest', 'WebSocket', 'localStorage', 'sessionStorage',
    'Uint8Array', 'Int8Array', 'Uint16Array', 'Int16Array', 'Uint32Array',
    'Int32Array', 'Float32Array', 'Float64Array', 'ArrayBuffer', 'DataView'
  ])

  const jsTokenPatterns = [
    { type: 'comment', re: /\/\/[^\n]*/y },
    { type: 'comment', re: /\/\*[\s\S]*?\*\//y },
    { type: 'string', re: /"(?:[^"\\]|\\.)*"/y },
    { type: 'string', re: /'(?:[^'\\]|\\.)*'/y },
    { type: 'string', re: /`(?:[^`\\]|\\.)*`/y },
    { type: 'regex', re: /\/(?![*/])(?:[^\\/\n]|\\.)+\/[gimsuy]*/y },
    { type: 'number', re: /\b(?:0x[\da-fA-F]+|0b[01]+|0o[0-7]+|\d+\.?\d*(?:e[+-]?\d+)?)\b/y },
    { type: 'operator', re: /[+\-*/%=<>!&|^~?:]+|\.{3}/y },
    { type: 'word', re: /[a-zA-Z_$][\w$]*/y },
    { type: 'punctuation', re: /[{}()\[\];,.]/y },
    { type: 'whitespace', re: /\s+/y },
  ]

  function highlightJSCode(code) {
    let html = ''
    let i = 0
    const escapeHtml = s => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')

    while (i < code.length) {
      let matched = false
      for (const pat of jsTokenPatterns) {
        pat.re.lastIndex = i
        const match = pat.re.exec(code)
        if (match && match.index === i) {
          const token = match[0]
          let className = null

          if (pat.type === 'comment') className = 'js-comment'
          else if (pat.type === 'string') className = 'js-string'
          else if (pat.type === 'number') className = 'js-number'
          else if (pat.type === 'regex') className = 'js-regex'
          else if (pat.type === 'operator') className = 'js-operator'
          else if (pat.type === 'word') {
            if (jsKeywords.has(token)) className = 'js-keyword'
            else if (jsBuiltins.has(token)) className = 'js-builtin'
            else if (i + token.length < code.length && code[i + token.length] === '(') className = 'js-function'
          }

          html += className ? `<span class="${className}">${escapeHtml(token)}</span>` : escapeHtml(token)
          i += token.length
          matched = true
          break
        }
      }
      if (!matched) {
        html += escapeHtml(code[i])
        i++
      }
    }
    return html
  }

  function createCodeEditor(rawCode) {
    // Extract the code body from the fenced block
    const firstNewline = rawCode.indexOf('\n')
    const codeBody = rawCode.slice(firstNewline + 1, -4).trim() // Remove fence and closing ```

    const container = document.createElement('div')
    container.className = 'code-editor'
    container.contentEditable = 'false'

    // Store raw markdown for saving
    container.dataset.raw = rawCode

    // Header with language label and action buttons
    const header = document.createElement('div')
    header.className = 'code-editor-header'

    const langLabel = document.createElement('span')
    langLabel.className = 'code-editor-lang'
    langLabel.textContent = 'JavaScript'

    const actions = document.createElement('div')
    actions.className = 'code-editor-actions'

    const copyBtn = document.createElement('button')
    copyBtn.className = 'code-editor-btn copy'
    copyBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Copy`

    const runBtn = document.createElement('button')
    runBtn.className = 'code-editor-btn run'
    runBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>Run`

    actions.appendChild(copyBtn)
    actions.appendChild(runBtn)
    header.appendChild(langLabel)
    header.appendChild(actions)

    // Code body with textarea for editing
    const body = document.createElement('div')
    body.className = 'code-editor-body'

    const textarea = document.createElement('textarea')
    textarea.className = 'code-editor-textarea'
    textarea.value = codeBody
    textarea.spellcheck = false
    textarea.autocomplete = 'off'
    textarea.autocapitalize = 'off'

    // Syntax highlighting overlay
    const highlight = document.createElement('pre')
    highlight.className = 'code-editor-highlight'
    highlight.innerHTML = highlightJSCode(codeBody)

    body.appendChild(highlight)
    body.appendChild(textarea)

    // Output area
    const output = document.createElement('div')
    output.className = 'code-editor-output'
    output.style.display = 'none'

    const outputHeader = document.createElement('div')
    outputHeader.className = 'code-editor-output-header'

    const outputLabel = document.createElement('span')
    outputLabel.textContent = 'Output'

    const clearBtn = document.createElement('button')
    clearBtn.className = 'code-editor-output-clear'
    clearBtn.textContent = 'Clear'

    outputHeader.appendChild(outputLabel)
    outputHeader.appendChild(clearBtn)

    const outputContent = document.createElement('div')
    outputContent.className = 'code-editor-output-content'

    output.appendChild(outputHeader)
    output.appendChild(outputContent)

    container.appendChild(header)
    container.appendChild(body)
    container.appendChild(output)

    // Calculate initial height based on content lines to prevent flicker
    const lineCount = codeBody.split('\n').length
    const lineHeight = 21 // 14px font * 1.5 line-height
    const padding = 24 // 12px top + 12px bottom
    const initialHeight = Math.max(80, lineCount * lineHeight + padding)
    textarea.style.height = initialHeight + 'px'

    // Auto-resize textarea and sync highlight
    const autoResize = () => {
      textarea.style.height = 'auto'
      textarea.style.height = textarea.scrollHeight + 'px'
    }
    const updateHighlight = () => {
      highlight.innerHTML = highlightJSCode(textarea.value)
    }
    textarea.addEventListener('input', () => {
      autoResize()
      updateHighlight()
    })
    textarea.addEventListener('scroll', () => {
      highlight.scrollTop = textarea.scrollTop
      highlight.scrollLeft = textarea.scrollLeft
    })

    // Update raw data when code changes (for saving)
    const debouncedSave = debounce(500, save)
    textarea.addEventListener('input', () => {
      const lang = rawCode.match(/^```(\w*)/)?.[1] || 'js'
      container.dataset.raw = '```' + lang + '\n' + textarea.value + '\n```'
      // Trigger save directly (input is stopped from bubbling)
      debouncedSave()
    })

    // Copy button
    copyBtn.addEventListener('click', async (e) => {
      e.stopPropagation()
      try {
        await navigator.clipboard.writeText(textarea.value)
        copyBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>Copied!`
        setTimeout(() => {
          copyBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Copy`
        }, 2000)
      } catch (err) {
        console.error('Failed to copy:', err)
      }
    })

    // Run button
    runBtn.addEventListener('click', (e) => {
      e.stopPropagation()
      output.style.display = 'block'
      outputContent.innerHTML = ''

      // Create a custom console to capture output
      const logs = []
      const customConsole = {
        log: (...args) => logs.push({ type: 'log', args }),
        error: (...args) => logs.push({ type: 'error', args }),
        warn: (...args) => logs.push({ type: 'warn', args }),
        info: (...args) => logs.push({ type: 'info', args }),
        clear: () => { logs.length = 0 },
      }

      try {
        // Create a function with custom console in scope
        const fn = new Function('console', textarea.value)
        fn(customConsole)

        // Render logs
        logs.forEach(({ type, args }) => {
          const line = document.createElement('div')
          line.className = type
          line.textContent = args.map(arg => {
            if (typeof arg === 'object') {
              try { return JSON.stringify(arg, null, 2) }
              catch { return String(arg) }
            }
            return String(arg)
          }).join(' ')
          outputContent.appendChild(line)
        })

        if (logs.length === 0) {
          const line = document.createElement('div')
          line.className = 'info'
          line.textContent = 'âœ“ Code executed successfully (no output)'
          outputContent.appendChild(line)
        }
      } catch (err) {
        const line = document.createElement('div')
        line.className = 'error'
        line.textContent = err.toString()
        outputContent.appendChild(line)
      }
    })

    // Clear button
    clearBtn.addEventListener('click', (e) => {
      e.stopPropagation()
      output.style.display = 'none'
      outputContent.innerHTML = ''
    })

    // Prevent editor from handling clicks inside code editor
    container.addEventListener('click', e => e.stopPropagation())
    container.addEventListener('mousedown', e => e.stopPropagation())
    container.addEventListener('keydown', e => e.stopPropagation())
    container.addEventListener('keyup', e => e.stopPropagation())
    container.addEventListener('input', e => e.stopPropagation())

    return container
  }

  function parseMarkdown() {
    const input = getArticleContent()
    const frag = document.createDocumentFragment()

    const matchers = [
      {name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y},
      {name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y},
      {name: 'md-h1', re: /^#[ \t]+[^\n]*$/my},
      {name: 'md-h2', re: /^##[ \t]+[^\n]*$/my},
      {name: 'md-h3', re: /^###[ \t]+[^\n]*$/my},
      {name: 'md-h4', re: /^####[ \t]+[^\n]*$/my},
      {name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my},
      {name: 'md-h6', re: /^######[ \t]+[^\n]*$/my},
      {name: 'md-code', re: /`[^`\n]*`/y},
      {name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y},
      {name: 'md-bold', re: /__[^_\n]+?__/y},
      {name: 'md-strike', re: /~~[^~\n]+?~~/y},
      {name: 'md-italic', re: /\*[^*\n]+?\*/y},
      {name: 'md-italic', re: /_[^_\n]+?_/y},
      {name: 'md-url', re: /https?:\/\/[^\s<>()\[\]{}"'`]+/y},
    ]

    const specials = ['`', '~', '*', '#', '_', 'h']

    let i = 0
    while (i < input.length) {
      let matched = false
      for (const m of matchers) {
        m.re.lastIndex = i
        const res = m.re.exec(input)
        if (res && res.index === i) {
          const raw = res[0]
          if (m.name === 'md-url') {
            const a = document.createElement('a')
            a.className = 'md-url'
            a.href = raw
            a.textContent = raw
            a.target = '_blank'
            a.rel = 'noopener noreferrer'
            frag.appendChild(a)
          } else if (m.name === 'md-codeblock' && /^```(js|javascript)/i.test(raw)) {
            frag.appendChild(createCodeEditor(raw))
          } else {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw
            frag.appendChild(span)
          }
          i += raw.length
          matched = true
          break
        }
      }

      if (matched) continue

      let next = input.length
      for (const ch of specials) {
        const idx = input.indexOf(ch, i)
        if (idx !== -1 && idx < next) next = idx
      }

      if (next === i) {
        frag.appendChild(document.createTextNode(input[i]))
        i++
        continue
      }

      frag.appendChild(document.createTextNode(input.slice(i, next)))
      i = next
    }

    article.textContent = ''
    article.appendChild(frag)
    article.normalize()

    // Ensure there's a text node after any code editor at the end so user can type after it
    const lastChild = article.lastChild
    if (lastChild?.classList?.contains('code-editor')) {
      article.appendChild(document.createTextNode('\n'))
    }
  }

  function initUI() {
    const menu = document.querySelector('#menu')
    const button = document.querySelector('#button')
    const qr = document.querySelector('#qr')
    const shareLink = document.querySelector('#share-link')
    const saveAsHTML = document.querySelector('#save-as-html')
    const saveAsText = document.querySelector('#save-as-text')

    button.addEventListener('click', event => {
      if (event.clientX || event.targetTouches) ripple(event)
      menu.classList.toggle('visible')
      qr.setAttribute('href', '/qr' + location.hash)
      shareLink.setAttribute('href', location.href)
    })

    function hideMenu() {
      menu.classList.remove('visible')
    }

    function notify(message) {
      const notification = document.querySelector('#notification')
      notification.classList.add('visible')
      notification.textContent = message
      setTimeout(() => notification.classList.remove('visible'), 2e3)
    }

    document.body.addEventListener('click', event => {
      let t = event.target
      if (t.closest('#menu')) return
      if (t.closest('#button')) return
      if (t.closest('.ripple')) return
      menu.classList.remove('visible')
    })

    shareLink.addEventListener('click', event => {
      event.preventDefault()
      if (!navigator.clipboard) {
        alert('Your browser does not support clipboard API')
        return
      }
      navigator.clipboard.writeText(location.href)
      notify('Link copied')
      hideMenu()
    })
    saveAsHTML.addEventListener('click', event => {
      event.preventDefault()
      downloadHTML()
      hideMenu()
    })
    saveAsText.addEventListener('click', event => {
      event.preventDefault()
      downloadTXT()
      hideMenu()
    })
  }

  function ripple(event) {
    const button = event.currentTarget
    const circle = document.createElement('span')
    const diameter = Math.max(button.clientWidth, button.clientHeight)
    const radius = diameter / 2
    circle.style.width = circle.style.height = `${diameter}px`
    circle.style.left = `${(event.clientX || event.targetTouches[0].pageX) - button.offsetLeft - radius}px`
    circle.style.top = `${(event.clientY || event.targetTouches[0].pageY) - button.offsetTop - radius}px`
    circle.classList.add('ripple')
    const ripple = button.getElementsByClassName('ripple')[0]
    if (ripple) ripple.remove()
    button.appendChild(circle)
  }

  function Editor(element, highlight) {
    const listeners = []
    const history = []
    let at = -1, prev

    const isInsideCodeEditor = () => {
      const sel = window.getSelection()
      if (!sel.anchorNode) return false
      let node = sel.anchorNode
      while (node && node !== element) {
        if (node.classList?.contains('code-editor')) return true
        node = node.parentNode
      }
      return false
    }

    const debounceHighlight = debounce(30, () => {
      if (isInsideCodeEditor()) return
      const pos = save()
      highlight(element)
      restore(pos)
    })

    const shouldRecord = (event) => {
      return !isUndo(event) && !isRedo(event)
        && event.key !== 'Meta'
        && event.key !== 'Control'
        && event.key !== 'Alt'
        && !event.key.startsWith('Arrow')
    }

    let recording = false
    const debounceRecordHistory = debounce(300, (event) => {
      if (shouldRecord(event)) {
        recordHistory()
        recording = false
      }
    })

    const on = (type, fn) => {
      listeners.push([type, fn])
      element.addEventListener(type, fn)
    }
    on('keydown', event => {
      if (event.defaultPrevented) return
      prev = toString()
      if (isUndo(event)) doUndo(event)
      if (isRedo(event)) doRedo(event)
      if (shouldRecord(event) && !recording) {
        recordHistory()
        recording = true
      }
    })
    on('keyup', event => {
      if (event.defaultPrevented) return
      if (event.isComposing) return
      if (prev !== toString()) debounceHighlight()
      debounceRecordHistory(event)
    })
    on('paste', () => setTimeout(recordHistory, 10))
    on('cut', () => setTimeout(recordHistory, 10))
    on('beforeinput', event => {
      if (event.inputType === 'historyUndo') doUndo(event)
      if (event.inputType === 'historyRedo') doRedo(event)
    })

    function save() {
      const s = getSelection()
      const pos = {start: 0, end: 0, dir: undefined}
      let {anchorNode, anchorOffset, focusNode, focusOffset} = s
      if (!anchorNode || !focusNode) throw 'error1'
      if (anchorNode === element && focusNode === element) {
        pos.start = (anchorOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.end = (focusOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-'
        return pos
      }
      if (anchorNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset])
        anchorNode = node
        anchorOffset = 0
      }
      if (focusNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        focusNode.insertBefore(node, focusNode.childNodes[focusOffset])
        focusNode = node
        focusOffset = 0
      }
      visit(element, el => {
        if (el === anchorNode && el === focusNode) {
          pos.start += anchorOffset
          pos.end += focusOffset
          pos.dir = anchorOffset <= focusOffset ? '->' : '<-'
          return 'stop'
        }
        if (el === anchorNode) {
          pos.start += anchorOffset
          if (!pos.dir) {
            pos.dir = '->'
          } else {
            return 'stop'
          }
        } else if (el === focusNode) {
          pos.end += focusOffset
          if (!pos.dir) {
            pos.dir = '<-'
          } else {
            return 'stop'
          }
        }
        if (el.nodeType === Node.TEXT_NODE) {
          if (pos.dir !== '->') pos.start += el.nodeValue.length
          if (pos.dir !== '<-') pos.end += el.nodeValue.length
        }
      })

      element.normalize()
      return pos
    }

    function restore(pos) {
      const s = getSelection()
      let startNode, startOffset = 0
      let endNode, endOffset = 0

      if (!pos.dir) pos.dir = '->'
      if (pos.start < 0) pos.start = 0
      if (pos.end < 0) pos.end = 0

      if (pos.dir === '<-') {
        const {start, end} = pos
        pos.start = end
        pos.end = start
      }

      let current = 0

      visit(element, el => {
        if (el.nodeType !== Node.TEXT_NODE) return

        const len = (el.nodeValue || '').length
        if (current + len > pos.start) {
          if (!startNode) {
            startNode = el
            startOffset = pos.start - current
          }
          if (current + len > pos.end) {
            endNode = el
            endOffset = pos.end - current
            return 'stop'
          }
        }
        current += len
      })

      if (!startNode) {
        startNode = element
        startOffset = element.childNodes.length
      }
      if (!endNode) {
        endNode = element
        endOffset = element.childNodes.length
      }

      if (pos.dir === '<-') {
        [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset]
      }

      {
        const startEl = uneditable(startNode)
        if (startEl) {
          const node = document.createTextNode('')
          startEl.parentNode?.insertBefore(node, startEl)
          startNode = node
          startOffset = 0
        }
        const endEl = uneditable(endNode)
        if (endEl) {
          const node = document.createTextNode('')
          endEl.parentNode?.insertBefore(node, endEl)
          endNode = node
          endOffset = 0
        }
      }

      s.setBaseAndExtent(startNode, startOffset, endNode, endOffset)
      element.normalize()
    }

    function uneditable(node) {
      while (node && node !== element) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.getAttribute('contenteditable') === 'false') {
            return node
          }
        }
        node = node.parentNode
      }
    }

    function doUndo(event) {
      preventDefault(event)
      at--
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at < 0) at = 0
    }

    function doRedo(event) {
      preventDefault(event)
      at++
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at >= history.length) at--
    }

    function recordHistory() {
      const html = element.innerHTML
      const pos = save()
      const lastRecord = history[at]
      if (
        lastRecord
        && lastRecord.html === html
        && lastRecord.pos.start === pos.start
        && lastRecord.pos.end === pos.end
      ) return
      at++
      history[at] = {html, pos}
      history.splice(at + 1)
      const maxHistory = 10_000
      if (at > maxHistory) {
        at = maxHistory
        history.splice(0, 1)
      }
    }

    function visit(editor, visitor) {
      const queue = []
      if (editor.firstChild) queue.push(editor.firstChild)
      let el = queue.pop()
      while (el) {
        if (visitor(el) === 'stop') break
        if (el.nextSibling) queue.push(el.nextSibling)
        // Skip children of code-editor elements (they're non-editable)
        if (el.firstChild && !el.classList?.contains('code-editor')) queue.push(el.firstChild)
        el = queue.pop()
      }
    }

    function isCtrl(event) {
      return event.metaKey || event.ctrlKey
    }

    function isUndo(event) {
      return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ'
    }

    function isRedo(event) {
      return isCtrl(event) && event.shiftKey && event.code === 'KeyZ'
    }

    function toString() {
      return element.textContent || ''
    }

    function preventDefault(event) {
      event.preventDefault()
    }

    function getSelection() {
      return element.getRootNode().getSelection()
    }

    return {
      set(content) {
        element.textContent = content
        highlight(element)
      },
      destroy() {
        for (const [type, fn] of listeners) editor.removeEventListener(type, fn)
      },
    }
  }
</script>
<svg style="display: none" aria-hidden="true" focusable="false">
  <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"
          class="icon icon-tabler icons-tabler-outline icon-tabler-plus">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M12 5l0 14"/>
    <path d="M5 12l14 0"/>
  </symbol>
  <symbol id="icon-share" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
          stroke-linecap="round"
          stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1"/>
    <path d="M12 14v-11"/>
    <path d="M9 6l3 -3l3 3"/>
  </symbol>
  <symbol id="icon-qrcode" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 17l0 .01"/>
    <path d="M14 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 7l0 .01"/>
    <path d="M4 15a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M17 7l0 .01"/>
    <path d="M14 14l3 0"/>
    <path d="M20 14l0 .01"/>
    <path d="M14 14l0 3"/>
    <path d="M14 20l3 0"/>
    <path d="M17 17l3 0"/>
    <path d="M20 17l0 3"/>
  </symbol>
  <symbol id="icon-github" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path
      d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"/>
  </symbol>
  <symbol id="icon-empty" viewBox="0 0 24 24"></symbol>
</svg>
